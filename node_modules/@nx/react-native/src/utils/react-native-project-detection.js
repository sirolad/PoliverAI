"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isReactNativeProject = isReactNativeProject;
exports.getAllReactNativeProjects = getAllReactNativeProjects;
const devkit_1 = require("@nx/devkit");
const config_utils_1 = require("@nx/devkit/src/utils/config-utils");
async function getAppConfig(tree, projectRoot, appConfigPath) {
    const absolutePath = (0, devkit_1.joinPathFragments)(tree.root, projectRoot, appConfigPath);
    return (0, config_utils_1.loadConfigFile)(absolutePath);
}
/**
 * Determines if a project is a React Native project by checking for specific files
 * and ensuring it's not an Expo project
 */
async function isReactNativeProject(tree, projectRoot) {
    // Check for required files
    const requiredFiles = ['metro.config.js', 'package.json'];
    const appConfigFiles = ['app.json', 'app.config.js', 'app.config.ts'];
    // Check if all required files exist
    for (const file of requiredFiles) {
        const filePath = (0, devkit_1.joinPathFragments)(projectRoot, file);
        if (!tree.exists(filePath)) {
            return {
                isReactNative: false,
                reason: `Missing required file: ${file}`,
            };
        }
    }
    // Check if at least one app config file exists
    let appConfigExists = false;
    let appConfigPath = null;
    for (const file of appConfigFiles) {
        const filePath = (0, devkit_1.joinPathFragments)(projectRoot, file);
        if (tree.exists(filePath)) {
            appConfigExists = true;
            appConfigPath = filePath;
            break;
        }
    }
    if (!appConfigExists) {
        return {
            isReactNative: false,
            reason: 'Missing app config file (app.json, app.config.js, or app.config.ts)',
        };
    }
    // Read package.json to check for Expo dependencies
    const packageJsonPath = (0, devkit_1.joinPathFragments)(projectRoot, 'package.json');
    let packageJson;
    try {
        packageJson = JSON.parse(tree.read(packageJsonPath, 'utf-8'));
    }
    catch (error) {
        return {
            isReactNative: false,
            reason: 'Failed to parse package.json',
        };
    }
    // Check for Expo in dependencies
    const hasExpoDependency = packageJson.dependencies?.['expo'] || packageJson.devDependencies?.['expo'];
    if (hasExpoDependency) {
        return {
            isReactNative: false,
            reason: 'Project has Expo dependency - this is an Expo project',
        };
    }
    // Read app config to check for Expo configuration
    let appConfig;
    let appConfigParseFailed = false;
    if (appConfigPath) {
        // Extract just the filename from the full path
        const filename = appConfigPath.split('/').pop();
        try {
            appConfig = await getAppConfig(tree, projectRoot, filename);
            if (appConfig === null) {
                appConfigParseFailed = true;
            }
        }
        catch (error) {
            appConfigParseFailed = true;
        }
    }
    if (appConfigParseFailed) {
        return {
            isReactNative: false,
            reason: 'Failed to parse app config file',
        };
    }
    // Check if app config has Expo configuration
    if (appConfig.expo) {
        return {
            isReactNative: false,
            reason: 'App config has Expo configuration',
        };
    }
    return {
        isReactNative: true,
    };
}
/**
 * Gets all React Native projects in the workspace
 */
async function getAllReactNativeProjects(tree, projects) {
    const reactNativeProjects = [];
    for (const [projectName, project] of projects.entries()) {
        const detection = await isReactNativeProject(tree, project.root);
        if (detection.isReactNative) {
            reactNativeProjects.push(projectName);
        }
    }
    return reactNativeProjects;
}
