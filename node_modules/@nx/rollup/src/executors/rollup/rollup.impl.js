"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rollupExecutor = rollupExecutor;
exports.createRollupOptions = createRollupOptions;
const rollup = require("rollup");
const path_1 = require("path");
const devkit_1 = require("@nx/devkit");
const normalize_1 = require("./lib/normalize");
const config_utils_1 = require("@nx/devkit/src/utils/config-utils");
const async_iterable_1 = require("@nx/devkit/src/utils/async-iterable");
const with_nx_1 = require("../../plugins/with-nx/with-nx");
const generate_package_json_1 = require("../../plugins/package-json/generate-package-json");
const buildable_libs_utils_1 = require("@nx/js/src/utils/buildable-libs-utils");
async function* rollupExecutor(rawOptions, context) {
    process.env.NODE_ENV ??= 'production';
    const options = (0, normalize_1.normalizeRollupExecutorOptions)(rawOptions, context);
    const rollupOptions = await createRollupOptions(options, context);
    const outfile = resolveOutfile(context, options);
    if (options.watch) {
        // region Watch build
        return yield* (0, async_iterable_1.createAsyncIterable)(({ next }) => {
            const watcher = rollup.watch(rollupOptions);
            watcher.on('event', (data) => {
                if (data.code === 'START') {
                    devkit_1.logger.info(`Bundling ${context.projectName}...`);
                }
                else if (data.code === 'END') {
                    devkit_1.logger.info('Bundle complete. Watching for file changes...');
                    next({ success: true, outfile });
                }
                else if (data.code === 'ERROR') {
                    devkit_1.logger.error(`Error during bundle: ${data.error.message}`);
                    next({ success: false });
                }
            });
            const processExitListener = (signal) => () => {
                watcher.close();
            };
            process.once('SIGTERM', processExitListener);
            process.once('SIGINT', processExitListener);
            process.once('SIGQUIT', processExitListener);
        });
        // endregion
    }
    else {
        // region Single build
        try {
            devkit_1.logger.info(`Bundling ${context.projectName}...`);
            const start = process.hrtime.bigint();
            const allRollupOptions = Array.isArray(rollupOptions)
                ? rollupOptions
                : [rollupOptions];
            for (const opts of allRollupOptions) {
                const bundle = await rollup.rollup(opts);
                const output = Array.isArray(opts.output) ? opts.output : [opts.output];
                for (const o of output) {
                    await bundle.write(o);
                }
            }
            const end = process.hrtime.bigint();
            const duration = `${(Number(end - start) / 1_000_000_000).toFixed(2)}s`;
            devkit_1.logger.info(`âš¡ Done in ${duration}`);
            return { success: true, outfile };
        }
        catch (e) {
            if (e.formatted) {
                devkit_1.logger.info(e.formatted);
            }
            else if (e.message) {
                devkit_1.logger.info(e.message);
            }
            devkit_1.logger.error(e);
            devkit_1.logger.error(`Bundle failed: ${context.projectName}`);
            return { success: false };
        }
        // endregion
    }
}
// -----------------------------------------------------------------------------
async function createRollupOptions(options, context) {
    const { dependencies } = (0, buildable_libs_utils_1.calculateProjectBuildableDependencies)(context.taskGraph, context.projectGraph, context.root, context.projectName, context.targetName, context.configurationName, true);
    const rollupConfig = (0, with_nx_1.withNx)(options, {}, dependencies);
    // `generatePackageJson` is a plugin rather than being embedded into @nx/rollup:rollup.
    // Make sure the plugin is always present to keep the previous before of Nx < 19.4, where it was not a plugin.
    const generatePackageJsonPlugin = Array.isArray(rollupConfig.plugins)
        ? rollupConfig.plugins.find((p) => p['name'] === generate_package_json_1.pluginName)
        : null;
    const userDefinedRollupConfigs = options.rollupConfig.map((plugin) => (0, config_utils_1.loadConfigFile)(plugin));
    let finalConfig = rollupConfig;
    for (const _config of userDefinedRollupConfigs) {
        const config = await _config;
        if (typeof config === 'function') {
            finalConfig = config(finalConfig, options);
        }
        else {
            finalConfig = {
                ...finalConfig,
                ...config,
                plugins: [
                    ...(Array.isArray(finalConfig.plugins) &&
                        finalConfig.plugins?.length > 0
                        ? finalConfig.plugins
                        : []),
                    ...(config.plugins?.length > 0 ? config.plugins : []),
                ],
            };
        }
    }
    if (generatePackageJsonPlugin &&
        Array.isArray(finalConfig.plugins) &&
        !finalConfig.plugins.some((p) => p['name'] === generate_package_json_1.pluginName)) {
        finalConfig.plugins.push(generatePackageJsonPlugin);
    }
    return finalConfig;
}
function resolveOutfile(context, options) {
    if (!options.format?.includes('cjs'))
        return undefined;
    const { name } = (0, path_1.parse)(options.outputFileName ?? options.main);
    return (0, path_1.resolve)(context.root, options.outputPath, `${name}.cjs.js`);
}
exports.default = rollupExecutor;
