"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withNxMetro = withNxMetro;
const devkit_1 = require("@nx/devkit");
const node_fs_1 = require("node:fs");
const path_1 = require("path");
// Cache for metro-config module
let metroConfig = null;
/**
 * Lazily require metro-config to handle cases where it might not be installed
 */
function getMetroConfig() {
    if (!metroConfig) {
        try {
            metroConfig = require('metro-config');
        }
        catch (error) {
            throw new Error('metro-config is required but not installed. Please install metro-config >= 0.82.0');
        }
    }
    return metroConfig;
}
const metro_resolver_1 = require("./metro-resolver");
async function withNxMetro(userConfig, opts = {}) {
    const extensions = ['', 'ts', 'tsx', 'js', 'jsx', 'json'];
    if (opts.debug)
        process.env.NX_REACT_NATIVE_DEBUG = 'true';
    if (opts.extensions)
        extensions.push(...opts.extensions);
    let watchFolders = (0, node_fs_1.readdirSync)(devkit_1.workspaceRoot)
        .filter((fileName) => !['dist', 'e2e'].includes(fileName) && !fileName.startsWith('.'))
        .map((fileName) => (0, path_1.join)(devkit_1.workspaceRoot, fileName))
        .filter((filePath) => (0, node_fs_1.statSync)(filePath).isDirectory());
    if (opts.watchFolders?.length) {
        watchFolders = watchFolders.concat(opts.watchFolders);
    }
    watchFolders = [...new Set(watchFolders)].filter((folder) => (0, node_fs_1.existsSync)(folder));
    const nxConfig = {
        resolver: {
            resolveRequest: (0, metro_resolver_1.getResolveRequest)(extensions, opts.exportsConditionNames, opts.mainFields),
            nodeModulesPaths: [(0, path_1.join)(devkit_1.workspaceRoot, 'node_modules')],
        },
        watchFolders,
    };
    const { mergeConfig } = getMetroConfig();
    return mergeConfig(userConfig, nxConfig);
}
