"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = startExecutor;
exports.runCliStart = runCliStart;
const devkit_1 = require("@nx/devkit");
const child_process_1 = require("child_process");
const path_1 = require("path");
const is_packager_running_1 = require("./lib/is-packager-running");
async function* startExecutor(options, context) {
    const projectRoot = context.projectsConfigurations.projects[context.projectName].root;
    await runCliStart(context.root, projectRoot, options);
    yield {
        port: options.port,
        success: true,
    };
}
/*
 * Starts the JS bundler and checks for "running" status before notifying
 * that packager has started.
 */
async function runCliStart(workspaceRoot, projectRoot, options) {
    const result = await (0, is_packager_running_1.isPackagerRunning)(options.port);
    if (result === 'running') {
        devkit_1.logger.info(`JS server already running on port ${options.port}.`);
    }
    else if (result === 'unrecognized') {
        devkit_1.logger.warn('JS server not recognized.');
    }
    else {
        // result === 'not_running'
        devkit_1.logger.info('Starting JS server...');
        try {
            return await startAsync(workspaceRoot, projectRoot, options);
        }
        catch (error) {
            devkit_1.logger.error(`Failed to start the packager server. Error details: ${error.message ?? error}`);
            throw error;
        }
    }
}
function startAsync(workspaceRoot, projectRoot, options) {
    return new Promise((resolve, reject) => {
        const childProcess = (0, child_process_1.fork)(require.resolve('react-native/cli.js'), ['start', ...createStartOptions(options)], {
            cwd: (0, path_1.resolve)(workspaceRoot, projectRoot),
            env: process.env,
            stdio: 'inherit',
        });
        childProcess.on('error', (err) => {
            reject(err);
        });
        childProcess.on('exit', (code) => {
            if (code === 0) {
                resolve(childProcess);
            }
            else {
                reject(code);
            }
        });
        const processExitListener = (signal) => () => {
            childProcess.kill(signal);
            process.exit();
        };
        process.once('exit', (signal) => childProcess.kill(signal));
        process.once('SIGTERM', processExitListener);
        process.once('SIGINT', processExitListener);
        process.once('SIGQUIT', processExitListener);
    });
}
function createStartOptions(options) {
    return Object.keys(options).reduce((acc, k) => {
        if (k === 'resetCache') {
            if (options[k] === true) {
                acc.push(`--reset-cache`);
            }
        }
        else if (k === 'interactive') {
            if (options[k] === false) {
                acc.push(`--no-interactive`);
            }
        }
        else {
            acc.push(`--${k}`, options[k]);
        }
        return acc;
    }, []);
}
