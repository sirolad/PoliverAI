"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNodesV2 = exports.createNodes = exports.createDependencies = void 0;
const cache_directory_1 = require("nx/src/utils/cache-directory");
const path_1 = require("path");
const fs_1 = require("fs");
const devkit_1 = require("@nx/devkit");
const calculate_hash_for_create_nodes_1 = require("@nx/devkit/src/utils/calculate-hash-for-create-nodes");
const js_1 = require("@nx/js");
const get_named_inputs_1 = require("@nx/devkit/src/utils/get-named-inputs");
const file_hasher_1 = require("nx/src/hasher/file-hasher");
const ts_solution_setup_1 = require("@nx/js/src/utils/typescript/ts-solution-setup");
const util_1 = require("@nx/js/src/plugins/typescript/util");
const pmc = (0, devkit_1.getPackageManagerCommand)();
function readTargetsCache(cachePath) {
    return (0, fs_1.existsSync)(cachePath) ? (0, devkit_1.readJsonFile)(cachePath) : {};
}
function writeTargetsToCache(cachePath, results) {
    (0, devkit_1.writeJsonFile)(cachePath, results);
}
/**
 * @deprecated The 'createDependencies' function is now a no-op. This functionality is included in 'createNodesV2'.
 */
const createDependencies = () => {
    return [];
};
exports.createDependencies = createDependencies;
const rollupConfigGlob = '**/rollup.config.{js,cjs,mjs,ts,cts,mts}';
exports.createNodes = [
    rollupConfigGlob,
    async (configFilePath, options, context) => {
        devkit_1.logger.warn('`createNodes` is deprecated. Update your plugin to utilize createNodesV2 instead. In Nx 20, this will change to the createNodesV2 API.');
        return createNodesInternal(configFilePath, normalizeOptions(options), context, {}, (0, ts_solution_setup_1.isUsingTsSolutionSetup)());
    },
];
exports.createNodesV2 = [
    rollupConfigGlob,
    async (configFilePaths, options, context) => {
        const normalizedOptions = normalizeOptions(options);
        const optionsHash = (0, file_hasher_1.hashObject)(normalizedOptions);
        const cachePath = (0, path_1.join)(cache_directory_1.workspaceDataDirectory, `rollup-${optionsHash}.hash`);
        const targetsCache = readTargetsCache(cachePath);
        const isTsSolutionSetup = (0, ts_solution_setup_1.isUsingTsSolutionSetup)();
        try {
            return await (0, devkit_1.createNodesFromFiles)((configFile, _, context) => createNodesInternal(configFile, normalizedOptions, context, targetsCache, isTsSolutionSetup), configFilePaths, normalizedOptions, context);
        }
        finally {
            writeTargetsToCache(cachePath, targetsCache);
        }
    },
];
async function createNodesInternal(configFilePath, options, context, targetsCache, isTsSolutionSetup) {
    const projectRoot = (0, path_1.dirname)(configFilePath);
    const fullyQualifiedProjectRoot = (0, path_1.join)(context.workspaceRoot, projectRoot);
    // Do not create a project if package.json and project.json do not exist
    const siblingFiles = (0, fs_1.readdirSync)(fullyQualifiedProjectRoot);
    if (!siblingFiles.includes('package.json') &&
        !siblingFiles.includes('project.json')) {
        return {};
    }
    const hash = await (0, calculate_hash_for_create_nodes_1.calculateHashForCreateNodes)(projectRoot, options, context, [(0, js_1.getLockFileName)((0, devkit_1.detectPackageManager)(context.workspaceRoot))]);
    targetsCache[hash] ??= await buildRollupTarget(configFilePath, projectRoot, options, context, isTsSolutionSetup);
    return {
        projects: {
            [projectRoot]: {
                root: projectRoot,
                targets: targetsCache[hash],
            },
        },
    };
}
async function buildRollupTarget(configFilePath, projectRoot, options, context, isTsSolutionSetup) {
    let loadConfigFile;
    try {
        // Try to load the workspace version of rollup first (it should already exist).
        // Using the workspace rollup ensures that the config file is compatible with the `loadConfigFile` function.
        // e.g. rollup@2 supports having `require` calls in rollup config, but rollup@4 does not.
        const m = require(require.resolve('rollup/loadConfigFile', {
            paths: [(0, path_1.dirname)(configFilePath)],
        }));
        // Rollup 2 has this has default export, but it is named in 3 and 4.
        // See: https://www.unpkg.com/browse/rollup@2.79.1/dist/loadConfigFile.js
        loadConfigFile = typeof m === 'function' ? m : m.loadConfigFile;
    }
    catch {
        // Fallback to our own if needed.
        loadConfigFile = require('rollup/loadConfigFile').loadConfigFile;
    }
    const isTsConfig = configFilePath.endsWith('ts');
    const tsConfigPlugin = '@rollup/plugin-typescript';
    const namedInputs = (0, get_named_inputs_1.getNamedInputs)(projectRoot, context);
    const rollupConfig = (await loadConfigFile((0, devkit_1.joinPathFragments)(context.workspaceRoot, configFilePath), isTsConfig ? { configPlugin: tsConfigPlugin } : {}, true // Enable watch mode so that rollup properly reloads config files without reusing a cached version
    )).options;
    const outputs = getOutputs(rollupConfig, projectRoot);
    const targets = {};
    targets[options.buildTargetName] = {
        command: `rollup -c ${(0, path_1.basename)(configFilePath)}${isTsConfig
            ? ` --configPlugin typescript={tsconfig:\\'tsconfig.lib.json\\'}`
            : ''}`,
        options: { cwd: projectRoot },
        cache: true,
        dependsOn: [`^${options.buildTargetName}`],
        inputs: [
            ...('production' in namedInputs
                ? ['production', '^production']
                : ['default', '^default']),
            { externalDependencies: ['rollup'] },
        ],
        outputs,
        metadata: {
            technologies: ['rollup'],
            description: 'Run Rollup',
            help: {
                command: `${pmc.exec} rollup --help`,
                example: {
                    options: {
                        sourcemap: true,
                        watch: true,
                    },
                },
            },
        },
    };
    if (isTsSolutionSetup) {
        targets[options.buildTargetName].syncGenerators = [
            '@nx/js:typescript-sync',
        ];
    }
    (0, util_1.addBuildAndWatchDepsTargets)(context.workspaceRoot, projectRoot, targets, options, pmc);
    return targets;
}
function getOutputs(rollupConfigs, projectRoot) {
    const outputs = new Set();
    for (const rollupConfig of rollupConfigs) {
        if (rollupConfig.output) {
            const rollupConfigOutputs = [];
            if (Array.isArray(rollupConfig.output)) {
                rollupConfigOutputs.push(...rollupConfig.output);
            }
            else {
                rollupConfigOutputs.push(rollupConfig.output);
            }
            for (const output of rollupConfigOutputs) {
                const outputPathFromConfig = output.dir
                    ? output.dir
                    : output.file
                        ? (0, path_1.dirname)(output.file)
                        : 'dist';
                const outputPath = projectRoot === '.'
                    ? (0, devkit_1.joinPathFragments)(`{workspaceRoot}`, outputPathFromConfig)
                    : (0, devkit_1.joinPathFragments)(`{workspaceRoot}`, projectRoot, outputPathFromConfig);
                outputs.add(outputPath);
            }
        }
    }
    return Array.from(outputs);
}
function normalizeOptions(options) {
    return {
        buildTargetName: options.buildTargetName ?? 'build',
        buildDepsTargetName: options.buildDepsTargetName ?? 'build-deps',
        watchDepsTargetName: options.watchDepsTargetName ?? 'watch-deps',
    };
}
